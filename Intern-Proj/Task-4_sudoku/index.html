<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Solver | Blue Grid Challenge</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* ---------------------------------- */
        /* CSS: Vibrant Soft & Dark Blue Theme */
        /* ---------------------------------- */
        
        /* Define Colors and Font */
        :root {
            --color-dark-blue: #0A192F;    /* Deep Navy Background */
            --color-soft-teal: #64FFDA;    /* Vibrant Accent/Glow */
            --color-vibrant-blue: #4A89F7; /* Button/Hover Fill */
            --color-light-text: #E6E6E6;   /* Main Text/Grid Numbers */
            --color-error: #FF6464;        /* Error Messages */
        }

        body {
            font-family: 'Orbitron', sans-serif; /* Gaming Font */
            background-color: var(--color-dark-blue);
            color: var(--color-light-text);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 0;
            margin: 0;
            min-height: 100vh;
        }

        h1 {
            color: var(--color-soft-teal);
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(100, 255, 218, 0.6); /* Soft Glow */
            margin-bottom: 30px;
            letter-spacing: 2px;
        }

        /* --- Grid Container Styling --- */
        #sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 500px; /* Slightly larger grid */
            height: 500px;
            
            /* Main Grid Border (Thick, Glowing) */
            border: 4px solid var(--color-vibrant-blue); 
            box-shadow: 0 0 25px rgba(74, 137, 247, 0.5); 
            margin-bottom: 30px;
        }

        /* --- Cell and Input Styling --- */
        .cell {
            border: 1px solid #203A5F; /* Subtler inner lines */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #0d2645; /* Slightly lighter inner cell background */
            transition: background-color 0.2s;
        }
        
        .cell input {
            width: 90%;
            height: 90%;
            border: none;
            font-size: 28px;
            text-align: center;
            background-color: transparent;
            color: var(--color-light-text); /* Input text color */
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            outline: none;
            cursor: pointer;
        }
        /* Remove number arrows for Chrome/Safari */
        .cell input::-webkit-outer-spin-button,
        .cell input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Highlight the active/hovered cell (Gaming focus) */
        .cell:hover {
            background-color: #1a426f;
        }

        /* --- Major 3x3 Box Borders --- */
        /* Vertical separators */
        .cell:nth-child(3n) { border-right: 3px solid var(--color-vibrant-blue); }
        .cell:nth-child(9n) { border-right: 1px solid #203A5F; } /* Reset right edge */
        
        /* Horizontal separators */
        #sudoku-grid div:nth-child(n + 19):nth-child(-n + 27),
        #sudoku-grid div:nth-child(n + 46):nth-child(-n + 54) {
            border-bottom: 3px solid var(--color-vibrant-blue);
        }
        
        /* Reset border for the bottom edge of the entire grid */
        #sudoku-grid div:nth-child(n + 73) {
            border-bottom: 1px solid #203A5F; 
        }

        /* --- Number Styling --- */

        /* Numbers provided by the user (static) */
        .static-number {
            color: var(--color-soft-teal); 
            font-weight: 700;
        }

        /* Numbers filled by the solver (Glow effect) */
        .solved-number {
            color: #FFD700; /* Gold/Yellow for solved numbers for high contrast */
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.7); 
            animation: fadeIn 0.5s ease-out;
        }

        /* --- Button Styling (Gaming Look) --- */
        .controls {
            display: flex;
            gap: 20px;
        }

        .controls button {
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            border: 2px solid var(--color-soft-teal);
            border-radius: 8px;
            background-color: var(--color-dark-blue);
            color: var(--color-soft-teal);
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 5px rgba(100, 255, 218, 0.5);
        }

        .controls button:hover {
            background-color: var(--color-vibrant-blue);
            color: var(--color-dark-blue);
            box-shadow: 0 0 20px var(--color-vibrant-blue);
            transform: translateY(-2px);
        }
        
        /* --- Message Box --- */
        #message {
            margin-top: 25px;
            font-size: 1.2em;
            color: var(--color-error);
            text-shadow: 0 0 5px rgba(255, 100, 100, 0.5);
            min-height: 20px;
        }

        /* --- Animations --- */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

    </style>
</head>
<body>

    <h1>[ SUDOKU GRID CORE ]</h1>

    <div id="sudoku-grid">
        </div>

    <div class="controls">
        <button id="solve-btn">// EXECUTE SOLVE //</button>
        <button id="clear-btn">// RESET GRID //</button>
    </div>

    <p id="message"></p>

    <script>
        // ----------------------------------
        // JavaScript: Logic and DOM Interaction (UNCHANGED CORE LOGIC)
        // ----------------------------------

        const GRID_SIZE = 9;
        const gridElement = document.getElementById('sudoku-grid');
        const messageElement = document.getElementById('message');

        // --- 1. Sudoku Grid Setup (DOM) ---

        /** Generates the 9x9 input grid in the HTML */
        function createGrid() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    
                    const input = document.createElement('input');
                    input.type = 'text'; // Changed to text to better control input
                    input.maxLength = 1;
                    input.id = `cell-${r}-${c}`;
                    
                    // Input validation and cleanup
                    input.oninput = (e) => {
                        let value = e.target.value.replace(/[^1-9]/g, ''); // Only allow 1-9
                        if (value.length > 1) {
                            value = value.slice(-1); // Take only the last digit
                        }
                        e.target.value = value;

                        // Add/remove static class based on if the user entered a number
                        if (value) {
                            e.target.classList.add('static-number');
                        } else {
                            e.target.classList.remove('static-number');
                        }
                        e.target.classList.remove('solved-number'); // Clear solved style
                        messageElement.textContent = '';
                        messageElement.style.color = 'var(--color-error)'; // Reset message color
                    };

                    input.onfocus = (e) => {
                         // Remove static class on focus so the user can edit
                        e.target.classList.remove('static-number');
                    }
                    input.onblur = (e) => {
                         // Re-apply static class if a value exists when losing focus
                        if (e.target.value) {
                            e.target.classList.add('static-number');
                        }
                    }

                    cell.appendChild(input);
                    gridElement.appendChild(cell);
                }
            }
        }
        
        /** Reads the current values from the HTML grid into a 2D array */
        function getGridValues() {
            const grid = [];
            for (let r = 0; r < GRID_SIZE; r++) {
                const row = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    const input = document.getElementById(`cell-${r}-${c}`);
                    // Use parseInt and || 0 to get 0 for empty or invalid input
                    const value = parseInt(input.value) || 0; 
                    row.push(value);
                }
                grid.push(row);
            }
            return grid;
        }

        /** Writes the solved 2D array back to the HTML grid */
        function setGridValues(initialGrid, solvedGrid) {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const input = document.getElementById(`cell-${r}-${c}`);
                    
                    // If the cell was originally empty (0), update it with the solved number
                    if (initialGrid[r][c] === 0) {
                        input.value = solvedGrid[r][c];
                        input.classList.remove('static-number'); // Ensure it's not the 'static' style
                        input.classList.add('solved-number'); // Apply the glowing solved style
                    } else {
                        // Ensure initial numbers keep the static style
                        input.classList.add('static-number');
                        input.classList.remove('solved-number');
                    }
                }
            }
        }

        /** Clears the grid */
        function clearGrid() {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const input = document.getElementById(`cell-${r}-${c}`);
                    input.value = '';
                    input.classList.remove('solved-number', 'static-number');
                }
            }
            messageElement.textContent = '';
            messageElement.style.color = 'var(--color-error)';
        }

        // --- 2. Sudoku Solver Logic (Backtracking) ---

        function findEmptyCell(grid) {
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (grid[r][c] === 0) {
                        return [r, c];
                    }
                }
            }
            return null;
        }

        function isValid(grid, num, r, c) {
            // Check Row
            for (let col = 0; col < GRID_SIZE; col++) {
                if (grid[r][col] === num) return false;
            }

            // Check Column
            for (let row = 0; row < GRID_SIZE; row++) {
                if (grid[row][c] === num) return false;
            }

            // Check 3x3 Box
            const boxStartR = Math.floor(r / 3) * 3;
            const boxStartC = Math.floor(c / 3) * 3;

            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[boxStartR + i][boxStartC + j] === num) return false;
                }
            }
            return true;
        }

        /** The main recursive backtracking solver function */
        function solveSudoku(grid) {
            const pos = findEmptyCell(grid);

            if (!pos) {
                return true;
            }

            const [r, c] = pos;

            for (let num = 1; num <= 9; num++) {
                if (isValid(grid, num, r, c)) {
                    grid[r][c] = num;
                    if (solveSudoku(grid)) {
                        return true;
                    }
                    grid[r][c] = 0; // BACKTRACK
                }
            }
            return false;
        }

        // --- 3. Event Handlers ---

        document.getElementById('solve-btn').addEventListener('click', () => {
            messageElement.textContent = '';
            
            const initialGrid = getGridValues();
            // Create a deep copy of the grid for the solver to manipulate
            const solvedGrid = initialGrid.map(row => [...row]); 

            // Simple check for initial validity (e.g., is the initial puzzle already broken?)
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const num = solvedGrid[r][c];
                    // Temporarily set cell to 0, check if the existing number is valid at that position
                    if (num !== 0) {
                         solvedGrid[r][c] = 0; // Remove it
                         if (!isValid(solvedGrid, num, r, c)) {
                             messageElement.style.color = 'var(--color-error)';
                             messageElement.textContent = "Error: Initial puzzle input is invalid!";
                             return;
                         }
                         solvedGrid[r][c] = num; // Put it back
                    }
                }
            }

            if (solveSudoku(solvedGrid)) {
                setGridValues(initialGrid, solvedGrid);
                messageElement.style.color = 'var(--color-soft-teal)';
                messageElement.textContent = "[[ SOLVE SUCCESSFUL ]]";
            } else {
                messageElement.style.color = 'var(--color-error)';
                messageElement.textContent = "[[ NO SOLUTION FOUND ]]";
            }
        });

        document.getElementById('clear-btn').addEventListener('click', clearGrid);

        // Initialize the grid when the page loads
        createGrid();
    </script>

</body>
</html>